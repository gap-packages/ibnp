<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (IBNP) - Chapter 6: Noncommutative Involutive Bases</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap6_mj.html">[MathJax on]</a></p>
<p><a id="X797E483A84214975" name="X797E483A84214975"></a></p>
<div class="ChapSects"><a href="chap6.html#X797E483A84214975">6 <span class="Heading">Noncommutative Involutive Bases</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X7A86C2437F6EB83D">6.1 <span class="Heading">Noncommutative Involutive Divisions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8593BCDB8402C46C">6.1-1 LeftDivision</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X784AF6B87B2B5E5D">6.1-2 RightDivision</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A979BF38311024C">6.1-3 LeftOverlapDivision</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X83CE05CF7CB18611">6.1-4 RightOverlapDivision</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X83A3B3F77C712DA1">6.1-5 <span class="Heading">Selecting a Division</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X86FAAD527E20A573">6.1-6 DivisionRecordNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X828DA2AE844847E9">6.1-7 IPolyReduceNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78935EBD85A02F3F">6.1-8 LoggedIPolyReduceNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EBFCE307BE928BA">6.1-9 VerifyLoggedRecordNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8189DEDD87CE1667">6.1-10 IAutoreduceNP</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X80C3BE018688AFB7">6.2 <span class="Heading">Computing a Noncommutative Involutive Basis</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A71E4CD7B43726B">6.2-1 InvolutiveBasisNP</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X7DB2608C86CA3B04">6.3 <span class="Heading">The Disjoint Cones Conditions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7D87860878548EF2">6.3-1 StrongLeftOverlapDivision</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X819FE8F87ACDB19C">6.3-2 StrongRightOverlapDivision</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">Noncommutative Involutive Bases</span></h3>

<p>When applying a noncommutative rewriting system we conventionally apply a rule <span class="SimpleMath">ℓ -&gt; r</span> to a word <span class="SimpleMath">w</span> if and only if <span class="SimpleMath">w</span> has the form <span class="SimpleMath">w = u ℓ v</span>, where <span class="SimpleMath">u</span> or <span class="SimpleMath">v</span> may be the empty word <span class="SimpleMath">ϵ</span>. Then <span class="SimpleMath">w</span> reduces to <span class="SimpleMath">urv</span>.</p>

<p>An <em>involutive monoid rewriting system</em> <span class="SimpleMath">I</span> will restrict these conventional reductions by imposing a limitation on the letters allowed in <span class="SimpleMath">u</span> and <span class="SimpleMath">v</span>. Sets <span class="SimpleMath">mathcalM^L_I(w)</span>, the <em>left multiplicative variables</em> for <span class="SimpleMath">w</span>, and <span class="SimpleMath">mathcalM^R_I(w)</span>, the <em>right multiplicative variables</em> for <span class="SimpleMath">w</span>, are defined by <span class="SimpleMath">I</span>.</p>

<p><a id="X7A86C2437F6EB83D" name="X7A86C2437F6EB83D"></a></p>

<h4>6.1 <span class="Heading">Noncommutative Involutive Divisions</span></h4>

<p>An <em>involutive division</em> <span class="SimpleMath">mathcalI</span> is a procedure for determining, given an arbitrary set of monomials <span class="SimpleMath">W</span>, sets of left and right multiplicative letters <span class="SimpleMath">mathcalM^L_I(ℓ,W)</span> and <span class="SimpleMath">mathcalM^R_I(ℓ,W)</span> for any <span class="SimpleMath">ℓ ∈ W</span>. Then set <span class="SimpleMath">mathcalM^L_I(W) = {mathcalM^L_I(ℓ,W) ∣ ℓ ∈ W}</span> and <span class="SimpleMath">mathcalM^R_I(W) = {mathcalM^R_I(ℓ,W) ∣ ℓ ∈ W}</span>.</p>

<p>An <em>involutive rewriting system</em> <span class="SimpleMath">I</span> is <em>based on <span class="SimpleMath">mathcalI</span></em> if <span class="SimpleMath">mathcalM^L_I(W)</span> and <span class="SimpleMath">mathcalM^R_I(W)</span> are determined using <span class="SimpleMath">mathcalI</span>, in which case we may write <span class="SimpleMath">mathcalM^L_mathcalI}(W)</span> and <span class="SimpleMath">mathcalM^R_mathcalI}(W)</span> for these sets of letters.</p>

<p>A word <span class="SimpleMath">ℓ</span> is an <em>involutive divisor</em> of <span class="SimpleMath">w</span>, written <span class="SimpleMath">ℓ ∣_I w</span>, if</p>


<ul>
<li><p><span class="SimpleMath">w = u ℓ v</span>;</p>

</li>
<li><p>either <span class="SimpleMath">u = ϵ</span>, or the <em>last</em> letter of <span class="SimpleMath">u</span> is <em>left</em> multiplicative for <span class="SimpleMath">ℓ</span>;</p>

</li>
<li><p>and either <span class="SimpleMath">v = ϵ</span>, or the <em>first</em> letter of <span class="SimpleMath">v</span> is <em>right</em> multiplicative for <span class="SimpleMath">ℓ</span>.</p>

</li>
</ul>
<p>When this is the case, <span class="SimpleMath">w</span> <em>involutively reduces</em> to <span class="SimpleMath">urv</span> by the rule <span class="SimpleMath">ℓ -&gt; r</span>.</p>

<p>For example, let <span class="SimpleMath">M = rws({x,y,z},~ {xy -&gt; z,~ yz -&gt; x})</span>, so that <span class="SimpleMath">W = {xy,yz}</span>. Choose left and right multiplicative variables as shown in the following table:</p>

<div class="pcenter"><table class="GAPDocTable">
<tr>
<td class="tdcenter"><span class="SimpleMath">ℓ</span></td>
<td class="tdcenter"><span class="SimpleMath">mathcalM^L_I(ℓ,W)</span></td>
<td class="tdcenter"><span class="SimpleMath">mathcalM^R_I(ℓ,W)</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">xy</span></td>
<td class="tdcenter"><span class="SimpleMath">{x,y,z}</span></td>
<td class="tdcenter"><span class="SimpleMath">{y,z}</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">yz</span></td>
<td class="tdcenter"><span class="SimpleMath">{y,z}</span></td>
<td class="tdcenter"><span class="SimpleMath">{x}</span></td>
</tr>
</table><br />
</div>

<p>We consider reductions of <span class="SimpleMath">w = xyzx</span>. Conventionally, both rules may be used, giving reductions <span class="SimpleMath">z^2x</span> and <span class="SimpleMath">x^3</span> respectively. Involutively, we see that <span class="SimpleMath">xy ∣_I xyzx</span> because <span class="SimpleMath">z</span> is right multiplicative for <span class="SimpleMath">xy</span>, but <span class="SimpleMath">yz not∣_I~ xyzx</span> because <span class="SimpleMath">x</span> is left nonmultiplicative for <span class="SimpleMath">yz</span>. Thus the only involutive reduction is <span class="SimpleMath">xyzx -&gt;_I z^2x</span>.</p>

<p>If an involutive division <span class="SimpleMath">mathcalI</span> determines the left and right multiplicative variables for a word <span class="SimpleMath">ℓ ∈ W</span> <em>independently</em> of the set <span class="SimpleMath">W</span>, then the division is known as a <em>global involutive division</em>. Otherwise <span class="SimpleMath">mathcalI</span> is a <em>local involutive division</em>.</p>

<p><a id="X8593BCDB8402C46C" name="X8593BCDB8402C46C"></a></p>

<h5>6.1-1 LeftDivision</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftDivision</code>( <var class="Arg">alg</var>, <var class="Arg">mons</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given a word <span class="SimpleMath">w</span>, the <em>left division</em> <span class="SimpleMath">◃</span> assigns all letters to be left multiplicative for <span class="SimpleMath">w</span>, and all letters to be right nonmultiplicative for <span class="SimpleMath">w</span>. The example is taken from Example 5.5.12 in the thesis <a href="chapBib.html#biBgareth-thesis">[Eva05]</a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A3 := Algebra3IBNP;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:=A3.1;;  b:=A3.2;; c:=A3.3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord := NCMonomialLeftLengthLexicographicOrdering( A3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M6 := [ a*b, a, b*c, a*c, c*b, c^2 ];;           </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U6 := GM2NMList( M6 );</span>
[ [ 1, 2 ], [ 1 ], [ 2, 3 ], [ 1, 3 ], [ 3, 2 ], [ 3, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftDivision( A3, U6, ord );   </span>
[ [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ] ], 
  [ [  ], [  ], [  ], [  ], [  ], [  ] ] ]

</pre></div>

<p><a id="X784AF6B87B2B5E5D" name="X784AF6B87B2B5E5D"></a></p>

<h5>6.1-2 RightDivision</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightDivision</code>( <var class="Arg">alg</var>, <var class="Arg">mons</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given a word <span class="SimpleMath">w</span>, the <em>right division</em> <span class="SimpleMath">▹</span> assigns all letters to be left nonmultiplicative for <span class="SimpleMath">w</span>, and all letters to be right multiplicative for <span class="SimpleMath">w</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightDivision( A3, U6, ord );</span>
[ [ [  ], [  ], [  ], [  ], [  ], [  ] ], 
  [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ] ] ]

</pre></div>

<p><a id="X7A979BF38311024C" name="X7A979BF38311024C"></a></p>

<h5>6.1-3 LeftOverlapDivision</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftOverlapDivision</code>( <var class="Arg">alg</var>, <var class="Arg">mons</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">W = {w_1, ..., w_m}</span>. The <em>left overlap division</em> <span class="SimpleMath">mathcalL</span> assumes, to begin with, that all letters are left and right multiplicative for every <span class="SimpleMath">w_i</span>. It then assigns some letters to be right nonmultiplicative as follows.</p>


<ul>
<li><p>Suppose <span class="SimpleMath">w_j ∈ W</span> is a <em>subword</em>, but not a suffix, of a (different) word <span class="SimpleMath">w_i ∈ W</span>. Then, for some <span class="SimpleMath">k</span>, we have <span class="SimpleMath">w_j =</span> Subword(<span class="SimpleMath">w_i,k,k+deg(w_j)-1</span>). Assign the letter in position <span class="SimpleMath">k+deg(w_j) ∈ w_i</span> to be right nonmultiplicative for <span class="SimpleMath">w_j</span>.</p>

</li>
<li><p>Suppose a proper <em>prefix</em> of <span class="SimpleMath">w_i</span> is equal to a proper <em>suffix</em> of a (not neccessarily different) <span class="SimpleMath">w_j</span>, and that <span class="SimpleMath">w_i</span> is not a proper subword of <span class="SimpleMath">w_j</span>, or vice versa. Then, for some <span class="SimpleMath">k</span>, we have Prefix(<span class="SimpleMath">w_i,k</span>) = Suffix(<span class="SimpleMath">w_j,k</span>). Assign the letter in position <span class="SimpleMath">k+1</span> in <span class="SimpleMath">w_i</span> to be right nonmultiplicative for <span class="SimpleMath">w_j</span>.</p>

</li>
</ul>
<p>Fox example, consider the rewriting system with rules <span class="SimpleMath">{ab^2 -&gt; b,~ ba^2 -&gt; a}</span>, so that the leading monomials are <span class="SimpleMath">{u=ab^2, v=ba^2}</span>. Neither monomial is a subword of the other, so the first rule above does not apply. Since Prefix(<span class="SimpleMath">v,1) = b =</span> Suffix(<span class="SimpleMath">u,1</span>), then <span class="SimpleMath">v[2]=a</span> is assigned to be right nonmulitplicative for <span class="SimpleMath">u</span>. By symmetry, <span class="SimpleMath">u[2]=b</span> is assigned to be right nonmulitplicative for <span class="SimpleMath">v</span>. The resulting sets are shown in the following table.</p>

<div class="pcenter"><table class="GAPDocTable">
<tr>
<td class="tdcenter"><span class="SimpleMath">w</span></td>
<td class="tdcenter"><span class="SimpleMath">mathcalM^L_mathcalL}(w,W)</span></td>
<td class="tdcenter"><span class="SimpleMath">mathcalM^R_mathcalL}(w,W)</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">u = ab^2</span></td>
<td class="tdcenter"><span class="SimpleMath">{a,b}</span></td>
<td class="tdcenter"><span class="SimpleMath">{b}</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">v = ba^2</span></td>
<td class="tdcenter"><span class="SimpleMath">{a,b}</span></td>
<td class="tdcenter"><span class="SimpleMath">{a}</span></td>
</tr>
</table><br />
</div>

<p>The following example takes <span class="SimpleMath">W</span> to be the list <code class="code">U6</code>, continuing Example 5.5.12 in the thesis <a href="chapBib.html#biBgareth-thesis">[Eva05]</a>. As <span class="SimpleMath">a</span> is a subword of <span class="SimpleMath">ab</span> and <span class="SimpleMath">ac</span>, so <span class="SimpleMath">b</span> and <span class="SimpleMath">c</span> are right nonmultiplicative for <span class="SimpleMath">a</span>. Secondly, <span class="SimpleMath">ab</span> and <span class="SimpleMath">cb</span> have suffix <span class="SimpleMath">b</span> which is a prefix of <span class="SimpleMath">bc</span>, so <span class="SimpleMath">c</span> is right nonmultiplicative for <span class="SimpleMath">ab</span> and <span class="SimpleMath">cb</span>. Thirdly, <span class="SimpleMath">ac, bc, c^2</span> all have suffix <span class="SimpleMath">c</span>, which is a prefix of <span class="SimpleMath">cb</span> and <span class="SimpleMath">c^2</span>, so <span class="SimpleMath">b</span> and <span class="SimpleMath">c</span> are both right nonmultiplicative for <span class="SimpleMath">ac, bc, c^2</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M6;</span>
[ (1)*a*b, (1)*a, (1)*b*c, (1)*a*c, (1)*c*b, (1)*c^2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftOverlapDivision( A3, U6, ord );               </span>
[ [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ] ], 
  [ [ 1, 2 ], [ 1 ], [ 1 ], [ 1 ], [ 1, 2 ], [ 1 ] ] ]

</pre></div>

<p><a id="X83CE05CF7CB18611" name="X83CE05CF7CB18611"></a></p>

<h5>6.1-4 RightOverlapDivision</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightOverlapDivision</code>( <var class="Arg">alg</var>, <var class="Arg">mons</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This division is the mirror image of <code class="code">LeftOverlapDivision</code>.</p>

<p>In the example, <span class="SimpleMath">a</span> is a prefix of <span class="SimpleMath">ab</span> and <span class="SimpleMath">ac</span> but is not a proper suffix of any monomial. However, <span class="SimpleMath">bc</span> has prefix <span class="SimpleMath">b</span> which is a suffix of <span class="SimpleMath">ab</span> and <span class="SimpleMath">cb</span>, so <span class="SimpleMath">a</span> and <span class="SimpleMath">c</span> and left nonmultiplicative for <span class="SimpleMath">bc</span>. Also <span class="SimpleMath">cb</span> and <span class="SimpleMath">c^2</span> have prefix <span class="SimpleMath">c</span> which is a suffix of <span class="SimpleMath">ac, bc, c^2</span>, so all of <span class="SimpleMath">a,b,c</span> are left nonmultiplicative for <span class="SimpleMath">cb</span> and <span class="SimpleMath">c^2</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightOverlapDivision( A3, U6, ord );               </span>
[ [ [ 1 .. 3 ], [ 1 .. 3 ], [ 2 ], [ 1 .. 3 ], [  ], [  ] ], 
  [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ] ] ]

</pre></div>

<p><a id="X83A3B3F77C712DA1" name="X83A3B3F77C712DA1"></a></p>

<h5>6.1-5 <span class="Heading">Selecting a Division</span></h5>

<p>The global variable <code class="code">NoncommutativeDivision</code> can take values "Left", "Right", "LeftOverlap", "RightOverlap", "StrongLeftOverlop" or "StrongRightOverlap". The default is "LeftOverlap". The example shows how to select the left overlap division.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NoncommutativeDivision := "LeftOverlap";</span>
"LeftOverlap"

</pre></div>

<p>Other divisions may be added in due course.</p>

<p><a id="X86FAAD527E20A573" name="X86FAAD527E20A573"></a></p>

<h5>6.1-6 DivisionRecordNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DivisionRecordNP</code>( <var class="Arg">alg</var>, <var class="Arg">mons</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation is called by the global function <code class="code">DivisionRecord</code> when the algebra is noncommutative. This operation finds the sets of multiplicative variables for a set of polynomials using one of the involutive divisions listed above. As in the commutative case, a three-field record <code class="code">drec</code> is returned: <code class="code">drec.div</code> is the division string; <code class="code">drec.mvars</code> is a two-element list, the first listing the sets of left multiplicative variables, and the second listing the sets of right multiplicative variables; <code class="code">drec.polys</code> is the list of polynomials in NP-format.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L3 := [ [ [ [1,2,2], [3] ], [1,-1] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ [ [2,3,3], [1] ], [1,-1] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ [ [3,1,1], [2] ], [1,-1] ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( L3 );</span>
 ab^2 - c 
 bc^2 - a 
 ca^2 - b 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">drec := DivisionRecord( A3, L3, ord );</span>
rec( div := "LeftOverlap", 
  mvars := [ [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ] ], 
      [ [ 1, 2 ], [ 2, 3 ], [ 1, 3 ] ] ], 
  polys := [ [ [ [ 1, 2, 2 ], [ 3 ] ], [ 1, -1 ] ], 
      [ [ [ 2, 3, 3 ], [ 1 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 1, 1 ], [ 2 ] ], [ 1, -1 ] ] ] )

</pre></div>

<p><a id="X828DA2AE844847E9" name="X828DA2AE844847E9"></a></p>

<h5>6.1-7 IPolyReduceNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IPolyReduceNP</code>( <var class="Arg">algebra</var>, <var class="Arg">polynomial</var>, <var class="Arg">DivisionRecord</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation is called by the global function <code class="code">IPolyReduce</code> when the algebra is noncommutative. This function reduces a polynomial <span class="SimpleMath">p</span> using the current overlap record for a basis, and an ordering.</p>

<p>In the example <span class="SimpleMath">p = 5c^2a^2b^2 + 6b^2c^2a^2 + 7a^2b^2c^2</span>. The monomial <span class="SimpleMath">c^2a^2b^2</span> reduces to <span class="SimpleMath">c^2ac</span> by <span class="SimpleMath">ab^2 -&gt; c</span>, since there are no letters to the right, but not by <span class="SimpleMath">ca^2 -&gt; b</span> since <span class="SimpleMath">b</span> is not right multiplicative for <span class="SimpleMath">ca^2</span>. The other terms are similar, and <span class="SimpleMath">p</span> reduces to <span class="SimpleMath">5c^2ac + 6b^2cb + 7a^2ba</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## choose a polynomial to reduce</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := 5*c^2*a^2*b^2 + 6*b^2*c^2*a^2 + 7*a^2*b^2*c^2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## convert to NP format and reduce</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lp := GP2NP( p );</span>
[ [ [ 3, 3, 1, 1, 2, 2 ], [ 2, 2, 3, 3, 1, 1 ], [ 1, 1, 2, 2, 3, 3 ] ], 
  [ 5, 6, 7 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lrp := IPolyReduce( A3, Lp, drec, ord );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## convert back to a polynomial</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rp := NP2GP( Lrp, A3 );</span>
(5)*c^2*a*c+(6)*b^2*c*b+(7)*a^2*b*a
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## p-rp should now belong to the ideal and reduce to 0</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := p - rp;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lq := GP2NP( q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lrq := IPolyReduce( A3, Lq, drec, ord );;</span>
[ [  ], [  ] ]

</pre></div>

<p><a id="X78935EBD85A02F3F" name="X78935EBD85A02F3F"></a></p>

<h5>6.1-8 LoggedIPolyReduceNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LoggedIPolyReduceNP</code>( <var class="Arg">algebra</var>, <var class="Arg">polynomial</var>, <var class="Arg">DivisionRecord</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation is called by the global function <code class="code">LoggedIPolyReduce</code> when the algebra is noncommutative. This function is similar to <code class="code">IPolyReduceNP</code>, reducing a polynomial <span class="SimpleMath">p</span> using the current overlap record for a basis, and an ordering. It's output, however, is a record containing, as well as the reduced polynomial <span class="SimpleMath">r</span>, logging information <span class="SimpleMath">L</span> which shows how the reduction has been obtained:</p>

<p class="pcenter">
p ~=~ r + \sum_{i,j} L[i][j][1] * L[i][j][2] * polys[i] * L[i][j][3].
</p>

<p>In the example <code class="code">r = logr.result</code> is equal to <span class="SimpleMath">Lrp</span>, and the equation above is then verified:</p>

<p class="pcenter">
p ~=~ r + 5c^2a(ab^2-c) + 7a^2b(bc^2-a) + 6b^2c(ca^2-b).
</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">logr := LoggedIPolyReduce( A3, Lp, drec, ord );  </span>
rec( logs := [ [ [ 5, [ 3, 3, 1 ], [  ] ] ], [ [ 7, [ 1, 1, 2 ], [  ] ] ], 
      [ [ 6, [ 2, 2, 3 ], [  ] ] ] ], 
  polys := [ [ [ [ 1, 2, 2 ], [ 3 ] ], [ 1, -1 ] ], 
      [ [ [ 2, 3, 3 ], [ 1 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 1, 1 ], [ 2 ] ], [ 1, -1 ] ] ], 
  result := [ [ [ 3, 3, 1, 3 ], [ 2, 2, 3, 2 ], [ 1, 1, 2, 1 ] ], [ 5, 6, 7 ] 
     ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">logr.result = Lrp;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := logr.logs;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p1 := ScalarMulNP( BimulNP( L[1][1][2], L3[1], L[1][1][3] ), L[1][1][1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p2 := ScalarMulNP( BimulNP( L[2][1][2], L3[2], L[2][1][3] ), L[2][1][1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := AddNP( p1, p2, 1, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p3 := ScalarMulNP( BimulNP( L[3][1][2], L3[3], L[3][1][3] ), L[3][1][1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := AddNP( q, p3, 1, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lp = AddNP( q, Lrp, 1, 1 );</span>
true

</pre></div>

<p><a id="X7EBFCE307BE928BA" name="X7EBFCE307BE928BA"></a></p>

<h5>6.1-9 VerifyLoggedRecordNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VerifyLoggedRecordNP</code>( <var class="Arg">polynomial</var>, <var class="Arg">LogRecord</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation checks the identity in the equation displayed above.</p>

<p>For a more complicated example, see file <code class="file">ibnp/tst/extras/reduce.tst</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerifyLoggedRecordNP( Lp, logr );</span>
true

</pre></div>

<p><a id="X8189DEDD87CE1667" name="X8189DEDD87CE1667"></a></p>

<h5>6.1-10 IAutoreduceNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IAutoreduceNP</code>( <var class="Arg">alg</var>, <var class="Arg">polys</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation is called by the global function <code class="code">IAutoreduce</code> when the algebra is noncommutative. This function applies <code class="code">IPolyReduceNP</code> to a list of polynomials recursively until no more reductions are possible. More specifically, this function involutively reduces each member of a list of polynomials with respect to all the other members of the list, removing the polynomial from the list if it is involutively reduced to 0. This process is iterated until no more reductions are possible.</p>

<p>If the set of polynomials is already reduced, then <code class="code">true</code> is returned.</p>

<p>In the example we form <code class="code">L4</code> by adding <code class="code">Lp</code> to <code class="code">L3</code>. Applying <code class="code">IAutoreduceNP</code>, only <span class="SimpleMath">p</span> reduces, and the concatenation of <code class="code">L3</code> with <span class="SimpleMath">Lrp</span> is returned.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L4 := Concatenation( L3, [Lp] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R4 := IAutoreduceNP( A3, L4, ord );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( R4 );</span>
 5c^2ac + 6b^2cb + 7a^2ba 
 ca^2 - b 
 bc^2 - a 
 ab^2 - c 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IAutoreduceNP( A3, R4, ord );</span>
true

</pre></div>

<p><a id="X80C3BE018688AFB7" name="X80C3BE018688AFB7"></a></p>

<h4>6.2 <span class="Heading">Computing a Noncommutative Involutive Basis</span></h4>

<p>The involutive algorithm for constructing an involutive basis in the noncommutative case also uses <em>prolongations</em> and <em>autoreduction</em>.</p>

<p><a id="X7A71E4CD7B43726B" name="X7A71E4CD7B43726B"></a></p>

<h5>6.2-1 InvolutiveBasisNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InvolutiveBasisNP</code>( <var class="Arg">alg</var>, <var class="Arg">polys</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation is called by the global function <code class="code">InvolutiveBasis</code> when the algebra is noncommutative. This function finds an involutive basis for the ideal generated by a set of polynomials, using a chosen ordering.</p>

<p>In the example we find that a Gröbner basis starting from <code class="code">L3</code> is rather large, so add a fourth polynomial <span class="SimpleMath">a^2b-c</span> defining the ideal. The resulting Gröbner basis then has just three terms. We then calculate an involutive basis, which has just seven terms. We also find the reduced form of <span class="SimpleMath">p</span> to be <span class="SimpleMath">18a^2</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gbas := SGrobner( L3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( gbas );         </span>
64
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## that's too large an example for this manual, so add a fourth poly</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K4 := Concatenation( L3, [ [ [ [1,1,2], [3] ], [1,-1] ] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( K4 );             </span>
 ab^2 - c 
 bc^2 - a 
 ca^2 - b 
 a^2b - c 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gbas := SGrobner( K4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( gbas );</span>
 b - a 
 c - a 
 a^3 - a 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## so the only reduced elements are {1,a,a^2} with a^3=a</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ibasK := InvolutiveBasis( A3, K4, ord );</span>
rec( div := "LeftOverlap", 
  mvars := 
    [ 
      [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], 
          [ 1 .. 3 ], [ 1 .. 3 ] ], 
      [ [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ] 
         ] ], 
  polys := [ [ [ [ 3, 1, 1 ], [ 1 ] ], [ 1, -1 ] ], 
      [ [ [ 2, 1, 1 ], [ 1 ] ], [ 1, -1 ] ], 
      [ [ [ 1, 1, 1 ], [ 1 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 1 ], [ 1, 1 ] ], [ 1, -1 ] ], 
      [ [ [ 2, 1 ], [ 1, 1 ] ], [ 1, -1 ] ], [ [ [ 3 ], [ 1 ] ], [ 1, -1 ] ], 
      [ [ [ 2 ], [ 1 ] ], [ 1, -1 ] ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( ibasK.polys );             </span>
 ca^2 - a 
 ba^2 - a 
 a^3 - a 
 ca - a^2 
 ba - a^2 
 c - a 
 b - a 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lr := IPolyReduce( A3, p, ibasK, ord );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNP( Lr );</span>
 18a^2 

</pre></div>

<p>In this simple example the left division produces the same basis, while the right and right overlap divisions <em>do not</em> produce (as might be expected) a mirror image basis.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NoncommutativeDivision := "RightOverlap";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ribasK := InvolutiveBasis( A3, K4, ord );;  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( ribasK.polys );                </span>
 a^3 - a 
 c - a 
 b - a 

</pre></div>

<p><a id="X7DB2608C86CA3B04" name="X7DB2608C86CA3B04"></a></p>

<h4>6.3 <span class="Heading">The Disjoint Cones Conditions</span></h4>

<p>The <em>disjoint right cones condition</em> for a set of monomials <span class="SimpleMath">W</span> requires that, for each monomial <span class="SimpleMath">w_i ∈ W</span>, at least one variable in every monomial <span class="SimpleMath">w_j ∈ W</span> is right nonmultiplicative for <span class="SimpleMath">w_i</span>. The <em>disjoint left cones condition</em> is the mirror image of this.</p>

<p><a id="X7D87860878548EF2" name="X7D87860878548EF2"></a></p>

<h5>6.3-1 StrongLeftOverlapDivision</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StrongLeftOverlapDivision</code>( <var class="Arg">alg</var>, <var class="Arg">mons</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The strong left overlap division is the extension of the left overlap division obtained by enforcing the disjoint right cones condition. This is achieved by considering all pairs <span class="SimpleMath">[w_i,w_j]</span> and, if no variable in <span class="SimpleMath">w_j</span> is right nonmultiplicative for <span class="SimpleMath">w_i</span>, then <span class="SimpleMath">w_j[1]</span> is removed from the list of right multiplicative variables for <span class="SimpleMath">w_i</span>.</p>

<p>In the example, the involutive basis using the left overlap division contains six polynomials with leading monomials <span class="SimpleMath">[c^2,cb,ca,ba,ac,ab]</span> and with corresponding right non-multiplicative variables <span class="SimpleMath">[[a,b,c],[a],[b,c],[b,c],[a,b,c],[a]]</span>. Every monomial contains either <span class="SimpleMath">b</span> or <span class="SimpleMath">c</span>. When using the strong left overlap division, the first change is in the case <span class="SimpleMath">i=j=2</span> when neither <span class="SimpleMath">b</span> nor <span class="SimpleMath">c</span> is non-multiplicative for <span class="SimpleMath">cb</span>. So <span class="SimpleMath">c</span> is made non-multiplicative for <span class="SimpleMath">w_2</span>. Similarly <span class="SimpleMath">c</span> is made non-multiplicative for <span class="SimpleMath">w_6 = ab</span>. The right multiplicative variables are now <span class="SimpleMath">[[~],[b],[a],[a],[~],[b]]</span>, and <code class="code">InvolutiveBasisNP</code> continues with this information.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P4 := [ [ [ [1,2], [3] ], [1,-2] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ [ [2,1], [3] ], [1,-2] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ [ [1,3], [2] ], [1,-2] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ [ [3,1], [2] ], [1,-2] ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( P4 );</span>
 ab - 2c 
 ba - 2c 
 ac - 2b 
 ca - 2b 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NoncommutativeDivision := "LeftOverlap";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ibasP := InvolutiveBasisNP( A3, P4, ord );</span>
rec( div := "LeftOverlap", 
  mvars := 
    [ 
      [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ]\
 
         ], [ [  ], [ 2, 3 ], [ 1 ], [ 1 ], [  ], [ 2, 3 ] ] ], 
  polys := [ [ [ [ 3, 3 ], [ 2, 2 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 2 ], [ 2, 3 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 1 ], [ 2 ] ], [ 1, -2 ] ], [ [ [ 2, 1 ], [ 3 ] ], [ 1, -2 ] ], 
      [ [ [ 1, 3 ], [ 2 ] ], [ 1, -2 ] ], [ [ [ 1, 2 ], [ 3 ] ], [ 1, -2 ] ] 
     ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( ibasP.polys );</span>
 c^2 - b^2 
 cb - bc 
 ca - 2b 
 ba - 2c 
 ac - 2b 
 ab - 2c 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## check that cbc reduces to b^3 and abc reduces to 2b^2</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IPolyReduce( A3, GP2NP( c*b*c ), ibasP, ord );</span>
[ [ [ 2, 2, 2 ] ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IPolyReduce( A3, GP2NP( a*b*c ), ibasP, ord );</span>
[ [ [ 2, 2 ] ], [ 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## now apply the strong left overlap division - two polynomials are added</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NoncommutativeDivision := "StrongLeftOverlap";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sbasP := InvolutiveBasisNP( A3, P4, ord );</span>
rec( div := "StrongLeftOverlap", 
  mvars := 
    [ 
      [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], 
          [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ] ], 
      [ [  ], [  ], [  ], [ 2 ], [ 1 ], [ 1 ], [  ], [ 2 ] ] ], 
  polys := [ [ [ [ 3, 2, 3 ], [ 2, 2, 2 ] ], [ 1, -1 ] ], 
      [ [ [ 1, 2, 3 ], [ 2, 2 ] ], [ 1, -2 ] ], 
      [ [ [ 3, 3 ], [ 2, 2 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 2 ], [ 2, 3 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 1 ], [ 2 ] ], [ 1, -2 ] ], [ [ [ 2, 1 ], [ 3 ] ], [ 1, -2 ] ], 
      [ [ [ 1, 3 ], [ 2 ] ], [ 1, -2 ] ], [ [ [ 1, 2 ], [ 3 ] ], [ 1, -2 ] ] 
     ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintNPList( sbasP.polys );</span>
 cbc - b^3 
 abc - 2b^2 
 c^2 - b^2 
 cb - bc 
 ca - 2b 
 ba - 2c 
 ac - 2b 
 ab - 2c 

</pre></div>

<p><a id="X819FE8F87ACDB19C" name="X819FE8F87ACDB19C"></a></p>

<h5>6.3-2 StrongRightOverlapDivision</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StrongRightOverlapDivision</code>( <var class="Arg">alg</var>, <var class="Arg">mons</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation is the mirror image of <code class="code">StrongLeftOverlapDivision</code>.</p>

<p>When we compute an involutive basis <code class="code">rbasP</code> using the right overlap division we find that <code class="code">rbasP.polys = ibasP.polys</code>. However there is just one left multiplicative variable for each of the polynomials and the left disjoint cones condition is already satisfied. So, when using the strong right overlap division, we get the same basis.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NoncommutativeDivision := "RightOverlap";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rbasP := InvolutiveBasisNP( A3, P4, ord );</span>
rec( div := "RightOverlap", 
  mvars := [ [ [ 2 ], [ 2 ], [ 2 ], [ 2 ], [ 1 ], [ 1 ] ], 
      [ [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], [ 1 .. 3 ], 
          [ 1 .. 3 ] ] ], 
  polys := [ [ [ [ 3, 3 ], [ 2, 2 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 2 ], [ 2, 3 ] ], [ 1, -1 ] ], 
      [ [ [ 3, 1 ], [ 2 ] ], [ 1, -2 ] ], [ [ [ 2, 1 ], [ 3 ] ], [ 1, -2 ] ], 
      [ [ [ 1, 3 ], [ 2 ] ], [ 1, -2 ] ], [ [ [ 1, 2 ], [ 3 ] ], [ 1, -2 ] ] 
     ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NoncommutativeDivision := "StrongRightOverlap";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">srbasP := InvolutiveBasisNP( A3, P4, ord );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">( rbasP.polys = srbasP.polys ) and ( rbasP.mvars = srbasP.mvars );</span>
true

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
