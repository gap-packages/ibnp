<?xml version="1.0" encoding="UTF-8"?> 

<Chapter Label="chap-ibases-cp">

<Heading>Commutative Involutive Bases</Heading>

Given a &Grob; Basis <M>G</M> for an ideal <M>J</M> 
over a polynomial ring <M>\mathcal{R}</M>, 
the remainder of any polynomial <M>p \in \mathcal{R}</M> 
with respect to <M>G</M> is unique. 
But, although this remainder is unique, there may be
many ways of obtaining this remainder, as it is possible that
several polynomials in <M>G</M> divide <M>p</M>, 
giving several <E>reduction paths</E> for <M>p</M>.

<Section Label="sec-cib">
<Heading>Reduction Paths</Heading>

<Subsection Label="subs-ch4ex402"> 
<Heading>An Example</Heading>
Consider the DegLex &Grob; basis 
<M>G := \{g_1, g_2, g_3\} = \{a^2-2ab+3, \: 2ab+b^2+5, \:
\frac{5}{4}b^3-\frac{5}{2}a+\frac{37}{4}b\}</M> 
over the polynomial ring <M>\mathbb{Q}[a,b]</M>,
and consider the polynomial <M>p := a^2b+b^3+8b</M>.
The remainder of <M>p</M> with respect to <M>G</M> is <M>0</M> 
(so that <M>p</M> is a member of the ideal <M>J</M> generated by <M>G</M>),
but there are two ways of obtaining this remainder, 
as shown in the following diagram.
<Display>
<![CDATA[
\vcenter{\xymatrix{
& a^2b+b^3+8b \ar[dl]_{g_1} \ar[dr]^{g_2} \\
2ab^2+b^3+5b \ar[d]_{g_2}
&& -\frac{1}{2}ab^2 + b^3 - \frac{5}{2}a+8b \ar[d]^{g_2} \\
0 && \frac{5}{4}b^3-\frac{5}{2}a+\frac{37}{4}b \ar[d]^{g_3} \\
&& 0
}}
]]></Display>
</Subsection>

An <E>Involutive Basis</E> for <M>J</M> is a &Grob; Basis <M>G</M> 
such that there is only <E>one</E> possible reduction path for any
polynomial <M>p \in \mathcal{R}</M>. 
In order to find such a basis, we restrict which reductions 
or divisions may take place by requiring, 
for each potential reduction of a polynomial <M>p</M> 
by a polynomial <M>g_i \in G</M> 
(so that <M>LM(p) = LM(g_i)\times u</M> for some monomial <M>u</M>), 
some extra conditions on the variables in <M>u</M> to be satisfied, 
namely that all variables in <M>u</M> have to be in a set of 
<E>multiplicative variables</E> for <M>g_i</M>, a set that is 
determined by a particular choice of an <E>involutive division</E>.
</Section>

<Section Label="sec-invdivc"> 
<Heading>Commutative Involutive Divisions</Heading>
Recall that a commutative monomial <M>u</M> is divisible by 
another monomial <M>w</M> if there exists a third monomial <M>u'</M>
such that <M>u = wu'</M>.
We use the notation <M>w \mid u</M> and refer to <M>w</M> 
as a <E>conventional</E> <Index>conventional divisor</Index>
divisor of <M>u</M>. 
An involutive division <M>I</M> partitions the variables in the
polynomial ring into sets of <E>multiplicative</E>
and <E>nonmultiplicative</E> variables for each polynomial.
The set of multiplicative variables for <M>w</M> is denoted by 
<M>\mathcal{M}_I(w)</M>.
Then <M>w</M> is an <E>involutive divisor</E> of <M>u</M>,
<Index>involutive divisor</Index> written <M>w \mid_I u</M>, 
if all variables in <M>u'</M> are in <M>\mathcal{M}_I(w)</M>.

<Subsection Label="subs-ch4ex411"> 
<Heading>Example</Heading>
Let <M>u := ab^3c</M>, <M>v := abc^3</M> 
and <M>w := bc</M> be three monomials
over the polynomial ring <M>\mathcal{R} := \mathbb{Q}[a,b,c]</M>. 
Let an involutive division <M>I</M> partition the variables 
in <M>\mathcal{R}</M> into the following two sets of variables 
for the monomial <M>w</M>:
multiplicative = <M>\{a,b\}</M>; nonmultiplicative = <M>\{c\}</M>.
It is true that <M>w</M> conventionally divides 
both monomials <M>u</M> and <M>v</M>,
but <M>w</M> only involutively divides monomial <M>u</M> as, 
defining <M>u' := ab^2</M> and <M>v' := ac^2</M> 
(so that <M>u = wu'</M> and <M>v = wv'</M>),
we observe that all variables in <M>u'</M> are in <M>\mathcal{M}_I(w)</M>, 
but the variables in <M>v'</M> (in particular the variable <M>c</M>) 
are not all in <M>\mathcal{M}_I(w)</M>.
So <M>w \mid_I u</M> and <M>w \nmid_I v</M>.
</Subsection>

<Subsection Label="subs-select-divcp"> 
<Heading>Selecting a Division</Heading>
<Index>CommutativeDivision</Index>
The global variable <C>CommutativeDivision</C> is a string which can take
values "Pommaret", "Thomas" or "Janet".
The default is "Pommaret".
The example shows how to select the Pommaret division.
</Subsection>
<Example>
<![CDATA[
gap> CommutativeDivision := "Pommaret";
"Pommaret"
]]>
</Example>

<Subsection Label="subs-select-ordcp"> 
<Heading>Selecting an Ordering</Heading>
<Index>orderings</Index>
These three divisions are defined for a set of monomials,
but we shall define a <C>DivisionRecord</C> below for a set of polynomials. 
The first step is therefore to select the leading monomials from this set,
and that will bepend of the <E>ordering</E> chosen.
We shall be using the orderings provided by the main &GAP; library
as described in <Ref Sect="sec-orderings"/>.
<P/>
When calling <C>MonomialLexOrdering</C>, <C>MonomialGrlexOrdering</C> etc.,
it is essential to provide a list of indeterminates, as shown in the example.
Otherwise some of the functions in this package will throw an error.
</Subsection>
<Example>
<![CDATA[
gap> R := PolynomialRing( Rationals, [ "x", "y", "z" ] );;
gap> x := R.1;; y := R.2;; z := R.3;;
gap> ord := MonomialLexOrdering( [x,y,z] );;
]]>
</Example>

<ManSection>
   <Oper Name="PommaretDivision"
         Arg="alg mons order" />
<Description>
Let <M>\mathcal{R} = \mathbb{F}[a_1,\ldots,a_n]</M>
with <M>a_1 > a_2 > \ldots > a_n</M>,
and let <M>w</M> be a polynomial in <M>\mathcal{R}</M> 
with leading monomoial 
<M>a_1^{e_1}a_2^{e_2} \ldots a_n^{e_n}</M> where 
<M>e_i</M> is the <E>first</E> non-zero exponent.
The Pommaret involutive division <M>\mathcal{P}</M> sets 
<M>\mathcal{M}_{\mathcal{P}}(w) = \{a_1, a_2, \ldots, a_i\}</M>.
<P/>
Because <M>\mathcal{M}_{\mathcal{P}}(w)</M> does not depend in any way on
the other leading monomials in <E>polys</E>, this is a <E>global</E> division.
<P/>
In the example the first five monomials <M>u_i</M> in <M>U</M> contain
a power of <M>x</M>, so <M>\mathcal{M}_{\mathcal{P}}(u_i) = \{x\}</M>.
Then <M>u_6</M> involves <M>y</M> and <M>z</M>,
so <M>\mathcal{M}_{\mathcal{P}}(u_6) = \{x,y\}</M>,
and similarly <M>\mathcal{M}_{\mathcal{P}}(u_7) = \{x,y,z\}</M>.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> U := [ x^5*y^2*z, x^4*y*z^2, x^2*y^2*z, x*y*z^3, x*z^3, y^2*z, z ];
[ x^5*y^2*z, x^4*y*z^2, x^2*y^2*z, x*y*z^3, x*z^3, y^2*z, z ]
gap> PommaretDivision( R, U, ord );
[ [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 1, 2 ], [ 1 .. 3 ] ]

]]>
</Example>

<ManSection>
   <Oper Name="ThomasDivision"
         Arg="alg mons order" />
<Description>
Let <M>\mathcal{R} = \mathbb{F}[a_1,\ldots,a_n]</M>
with <M>a_1 > a_2 > \ldots > a_n</M>,
and let <M>P</M> be a set of polynomials <M>P = \{p_1,\ldots,p_m\}</M>
in <M>\mathcal{R}</M> with leading monomials <M>U = \{u_1,\ldots,u_m\}</M>
where <M>u_i = a_1^{e^1_i}a_2^{e^2_i} \ldots a_n^{e^n_i}</M>. 
The Thomas involutive division <M>\mathcal{T}</M> sets 
<M>a_i</M> to be multiplicative for <M>p_j</M> and <M>u_j</M>
if <M>e^i_j = \max_k e^i_k</M> for all <M>1 \leqslant k \leqslant m</M>.
<P/>
In the example, using the same seven monomials,
the highest powers of <M>[x,y,z]</M> are <M>[5,2,3]</M> respectively.
So <M>x</M> is multiplicative only for <M>u_1</M>,
<M>y</M> is multiplicative for <M>\{u_1,u_3,u_6\}</M>,
and <M>z</M> is multiplicative only for <M>u_4</M> and <M>u_5</M>.
Note that two of the monomials have no multiplicative variable.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ThomasDivision( R, U, ord );
[ [ 1, 2 ], [  ], [ 2 ], [ 3 ], [ 3 ], [ 2 ], [  ] ]
]]>
</Example>

<ManSection>
   <Oper Name="JanetDivision"
         Arg="alg mons order" />
<Description>
Let <M>\mathcal{R} = \mathbb{F}[a_1,\ldots,a_n]</M>
with <M>a_1 > a_2 > \ldots > a_n</M>,
and let <M>P</M> be a set of polynomials <M>P = \{p_1,\ldots,p_m\}</M>
in <M>\mathcal{R}</M> with leading monomials <M>U = \{u_1,\ldots,u_m\}</M>
where <M>u_i = a_1^{e^1_i}a_2^{e^2_i} \ldots a_n^{e^n_i}</M>. 
The Janet involutive division <M>\mathcal{J}</M> sets <M>a_n</M>
to be multiplicative for <M>u_j</M> provided
<M>e^n_j = \max_k e^n_k</M> for all <M>1 \leqslant k \leqslant m</M>.
To determine whether <M>a_i</M> is multiplicative for <M>u_j</M>,
let <M>L = [e^{i+1}_j,e^{i+2}_j,\ldots,e^n_j]</M>.
Let <M>S</M> be the subset of <M>\{1,\ldots,m\}</M> containing those
<M>k</M> such that <M>[e^{i+1}_k,e^{i+2}_k,\ldots,e^n_k] = L</M>.
Then <M>a_i</M> is multiplicative for <M>u_j</M> provided
<M>e^i_j = \max_{k \in S}e^i_k</M>.
<P/>
In the example, recall that the exponent lists for the seven monomials are
<Display>
[5,2,1],~~~ [4,1,2],~~~ [2,2,1],~~~ [1,1,3],~~~ [1,0,3],~~~ [0,2,1],~~~ [0,0,1].
</Display>
As with the Thomas division, <M>\max_k e^3_k = 3</M> and
<M>z</M> is multiplicative only for <M>u_4</M> and <M>u_5</M>.
<P/>
For <M>y</M>, <M>L = [1]</M> when <M>k \in \{1,3,6,7\}</M>
and <M>\max_{\{1,3,6,7\}} e^2_k = 2</M>, so <M>y</M>
is multiplicative for <M>u_1, u_3</M> and <M>u_6</M>,
but not for <M>u_7</M>.
<M>L = [2]</M> only for <M>u_2</M>, so <M>y</M>
is multiplicative for <M>u_2</M>.
<M>L = [3]</M> for <M>u_4</M> and <M>u_5</M>, and <M>e^2_4 > e^2_5</M>,
so <M>y</M> is multiplicative for <M>u_4</M> but not <M>u_5</M>.
<P/>
For <M>x</M>, <M>L = [2,1]</M> for <M>k \in \{1,3,6\}</M> and
<M>e^1_1 = 5</M> is greater than <M>e^1_3</M> and <M>e^1_6</M>,
so <M>x</M> is multiplicative for <M>u_1</M>.
The other values for <M>L</M>, namely <M>[1,2], [1,3], [0,3]</M>
and <M>[0,1]</M>, occur just once each, so <M>x</M> is multiplicative
for <M>u_2, u_4, u_5</M> and <M>u_7</M>.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> JanetDivision( R, U, ord );
[ [ 1, 2 ], [ 1, 2 ], [ 2 ], [ 1, 2, 3 ], [ 1, 3 ], [ 2 ], [ 1 ] ]
]]>
</Example>

<ManSection>
   <Func Name="DivisionRecord"
         Arg="alg polys order" />
   <Oper Name="DivisionRecordCP"
         Arg="alg polys order" />
<Description>
The global function <C>DivisionRecord</C> calls one of the operations
<C>DivisionRecordCP</C> and <C>DivisionRecordNP</C>, depending on whether
the algebra is commutative or not.
In the commutative case, this function finds the sets of multiplicative
variables for a set of polynomials using one of the involutive divisions
listed above.
The record constructed has three fields: the chosen division;
a list of lists of positions of the multiplicative variables;
and the set of polynomials.
<P/>
In the following example, polynomials <M>\{u = b^3-3a, v=a^3-3b\}</M>
define an ideal and form a &Grob; basis for that ideal.
Using the Pommaret division, <M>\mathcal{M}_{\mathcal{P}}(u) = \{a,b\}</M>
and <M>\mathcal{M}_{\mathcal{P}}(v) = \{a\}</M>.
The variable <C>drec2.mvars</C> in the listing below contains the
<E>positions</E> of these variables in the generating set <M>\{a,b\}</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> R := PolynomialRing( Rationals, [ "a", "b" ] );;
gap> a := R.1;; b := R.2;;
gap> L2 := [ b^3 - 3*a, a^3 - 3*b ];;
gap> ord := MonomialGrlexOrdering( [a,b] );;
gap> GB2 := ReducedGroebnerBasis( L2, ord );;
gap> GB2 = L2;
true
gap> CommutativeDivision := "Pommaret";;
gap> drec2 := DivisionRecordCP( R, L2, ord );
rec( div := "Pommaret", mvars := [ [ 1, 2 ], [ 1 ] ], 
  polys := [ b^3-3*a, a^3-3*b ] )
]]>
</Example>

In the <E>reduction diagrams</E> below the nodes <M>(j,k)</M> 
represent the monomials <M>a^jb^k</M>. 
The lead monomials of <M>u</M> and <M>v</M> are marked by these two names.
In the left hand diagram the two shaded areas indicate those monomials 
which are conventionally reducible by <M>u</M> and by <M>v</M>, 
so that the doubly shaded area contains those monomials which are 
conventionally reducible by both. 
For an involutive division, this must be avoided.
<P/> 
In the right-hand diagram we see that <M>u</M> involutively divides 
the same set of monomials in the main shaded area. 
On the other hand <M>v</M> just involutively divides monomials 
<M>\{a^j \mid j \ge 3\}</M>. 
So none of the monomials <M>\{a^jb, a^jb^2 \mid j \ge 3\}</M> 
reduce by <M>v</M> involutively.
The operation <C>InvolutiveBasis</C>, to be described below, 
produces two further polynomials, <M>w = vb = a^3b-3b^2</M> and <M>vb^2</M>
which reduces by <M>u</M> to <M>x = a^3b^2 - 9a</M>. 
Both <M>w</M> and <M>x</M> have multiplicative variables <M>\{a\}</M> 
and the monomials which they can reduce lie on the two horizantal 
line segments in the right-hand diagram. 
In this way, all the conventionally reducible monomials 
are involutively reducible by just one of <M>\{u,v,w,x\}</M>. 
<P/>

<Display>
<![CDATA[
\vcenter{\xymatrix@=1em{
 b & & & \ar@{-}[ddddrrrr] & \ar@{-}[dddrrr] 
       & \ar@{-}[ddrr] & \ar@{-}[dr] & & & &  
   b & & & & & & & \\
: \ar[u] \ar@{-}[ur] & \cdot & \cdot 
              & \cdot \ar@{-}[ddddrrrr] & \cdot & \cdot & \cdot & & & &
   : \ar[u] \ar@{-}[ur] & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \\
 5 \ar@{-}[u] \ar@{-}[uurr] 
              & \cdot & \cdot & \cdot \ar@{-}[ddddrrrr]
                                      & \cdot & \cdot & \cdot & & & &
    5 \ar@{-}[u] \ar@{-}[uurr]
                 & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \\
 4 \ar@{-}[u] \ar@{-}[uuurrr] & \cdot & \cdot 
               & \cdot \ar@{-}[ddddrrrr] & \cdot & \cdot & \cdot & & & &
    4 \ar@{-}[u]  \ar@{-}[uuurrr]
                 & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \\
 u \ar@{-}[u] \ar@{-}[rrrrrrr] \ar@{-}[uuuurrrr]
              & \cdot \ar@{-}[uuuurrrr] & \cdot \ar@{-}[uuuurrrr] 
              & \cdot \ar@{-}[dddrrr] \ar@{-}[uuuurrrr] 
              & \cdot \ar@{-}[uuurrr] 
              & \cdot \ar@{-}[uurr] & \cdot \ar@{-}[ur] & & & &
              u \ar@{-}[u] \ar@{-}[rrrrrrr] \ar@{-}[uuuurrrr]
                & \cdot \ar@{-}[uuuurrrr] & \cdot \ar@{-}[uuuurrrr] 
                & \cdot \ar@{-}[uuuurrrr] & \cdot \ar@{-}[uuurrr] 
                & \cdot \ar@{-}[uurr] & \cdot \ar@{-}[ur] & & \\ 
 2 \ar@{-}[u] & \cdot & \cdot & \cdot \ar@{-}[ddrr] 
                & \cdot & \cdot & \cdot & & & &
    2 \ar@{-}[u] & \cdot & \cdot & x \ar@{-}[rrrr]& \cdot & \cdot & \cdot & \\
 1 \ar@{-}[u] & \cdot & \cdot & \cdot \ar@{-}[dr] 
                                      & \cdot & \cdot & \cdot & & & &
    1 \ar@{-}[u] & \cdot & \cdot & w \ar@{-}[rrrr] & \cdot & \cdot & \cdot & \\
 0 \ar@{-}[r]\ar@{-}[u] & 1 \ar@{-}[r] & 2 \ar@{-}[r] 
      & v \ar@{-}[r] \ar@{-}[uuuuuuu]
    & 4 \ar@{-}[r] & 5 \ar@{-}[r] & \cdots \ar[r] & a & & &
   0 \ar@{-}[r]\ar@{-}[u] & 1 \ar@{-}[r] & 2 \ar@{-}[r] 
        & v  \ar@{-}[r]
      & 4 \ar@{-}[r] & 5 \ar@{-}[r] & \cdots \ar[r] & a
}}
]]></Display>

<P/>
The polynomial <M>p = a^3b^3 + 2a^3b + 3ab^3</M> 
reduces involutively as follows.
<Display>
p \stackrel{u}{\longrightarrow} 3a^4 + 2a^3b + 3ab^3 
  \stackrel{v}{\longrightarrow} 2a^3b + 3ab^3 + 9ab 
  \stackrel{w}{\longrightarrow} 3ab^3 + 9ab + 6b^2 
  \stackrel{u}{\longrightarrow} 9a^2 + 9ab + 6b^2
</Display>
This reduction is computed in section <Ref Sect="InvolutiveBasis"/>.

<ManSection>
   <Func Name="IPolyReduce"
         Arg="algebra polynomial DivisionRecord order" />
   <Oper Name="IPolyReduceCP"
         Arg="algebra polynomial DivisionRecord order" />
<Description>
The global function <C>IPolyReduce</C> calls one of the operations
<C>IPolyReduceCP</C> and <C>IPolyReduceNP</C>
depending on whether the algebra is commutative or not.
This function reduces a polynomial <M>p</M> using the current
overlap record for a basis, and an ordering.
<P/>
In the example, using <C>drec2</C>, the polynomial <M>p</M> reduces 
only to <M>2a^3b+9a^2+9ab</M> 
<Display>
p \stackrel{u}{\longrightarrow} 3a^4 + 2a^3b + 3ab^3 
  \stackrel{v}{\longrightarrow} 2a^3b + 3ab^3 + 9ab 
  \stackrel{u}{\longrightarrow} 2a^3b + 9a^2 + 9ab
</Display>
because the polynomial <M>x</M>
is not available to reduce <M>2a^3b</M> to  <M>6b^2</M>.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> p := a^3*b^3 + 2*a^3*b + 3*a*b^3;;
gap> q := IPolyReduce( R, p, drec2, ord );
2*a^3*b+9*a^2+9*a*b
]]>
</Example>

<ManSection>
   <Func Name="LoggedIPolyReduce"
         Arg="algebra polynomial DivisionRecord order" />
   <Oper Name="LoggedIPolyReduceCP"
         Arg="algebra polynomial DivisionRecord order" />
<Description>
The global function <C>LoggedIPolyReduce</C> calls one of the operations
<C>LoggedIPolyReduceCP</C> and <C>LoggedIPolyReduceNP</C>
depending on whether the algebra is commutative or not.
This function is similar to <C>IPolyReduce</C>, 
reducing a polynomial <M>p</M> using the current
overlap record for a basis, and an ordering.
It's output, however, is a record containing, as well as the reduced
polynomial <M>r</M>, logging information which shows how the reduction 
has been obtained:
<Display>
p ~=~ r + \sum_i logs[i] * polys[i].
</Display>
<P/>
In the example <C>r.result</C> is equal to the previous result <M>q</M>,
and the equation above is verified:
<Display>
a^3b^3 + 2a^3b + 3ab^3 ~=~ (2a^3b+9a^2+9ab) + (a^3+3a)(b^3-3a) + 3a(a^3-3b).
</Display>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> r := LoggedIPolyReduceCP( R, p, drec2, ord );
rec( logs := [ a^3+3*a, 3*a ], polys := [ b^3-3*a, a^3-3*b ], 
  result := 2*a^3*b+9*a^2+9*a*b )
gap> r.result = q;
true
gap> p = r.result + r.logs[1]*r.polys[1] + r.logs[2]*r.polys[2];
true
]]>
</Example>

<ManSection>
   <Func Name="IAutoreduce"
         Arg="alg polys order" />
   <Oper Name="IAutoreduceCP"
         Arg="alg polys order" />
<Description>
The global function <C>IAutoreduce</C> calls one of the operations
<C>IAutoreduceCP</C> and <C>IAutoreduceNP</C>
depending on whether the algebra is commutative or not.
This function applies <C>IPolyReduce</C> to a list of polynomials recursively
until no more reductions are possible.
More specifically, this function involutively reduces each member of a
list of polynomials with respect to all the other members of the list, 
removing the polynomial from the list if it reduces involutively to <M>0</M>.
This process is iterated until no more reductions are possible.
<P/>
If no reduction takes place, so that the result is equal to the initial
list of polynomials, then <C>true</C> is returned.
<P/>
In the example we form <C>L3</C> by adding <M>p</M> to <C>L2</C>.
On applying <C>IAutoreduceCP</C>, only <M>p</M> reduces,
and the concatenation of <C>L2</C> with <M>q</M> is returned.
Starting with <C>L4 = [u,v,w,x]</C>, there are no reductions,
and <C>true</C> is returned.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> L3 := Concatenation( L2, [p] );;
gap> IAutoreduceCP( R, L3, ord );
[ b^3-3*a, a^3-3*b, 2*a^3*b+9*a^2+9*a*b ]
gap> L4 := Concatenation( L2, [ a^3*b-3*b^2, a^3*b^2-9*a ] );;
gap> IAutoreduceCP( R, L4, ord );
true
]]>
</Example>

</Section>


<Section Label="sec-compibc">
<Heading>Computing a Commutative Involutive Basis</Heading>

The involutive algorithm for constructing an involutive basis 
uses <E>prolongations</E> and <E>autoreduction</E>.

<Subsection Label="subs-prolong"> 
<Heading>Prolongations and Autoreduction</Heading>

Given a set of polynomials <M>P</M>, a <E>prolongation</E> of <M> p \in P</M>
is a product <M>pa_i</M> where the generator <M>a_i</M> is <E>not</E>
multiplicative with respect to the current involutive division.
<P/>
A set of polynomials <M>P</M> is said to be <E>autoreduced</E>
if no polynomial <M>p \in P</M> contains a term which is involutively divisible by some polynomial <M>p' \in P \setminus \{p\}</M>.
<P/>
We denote by <M>rem_I(p,Q)</M> the involutive remainder of 
polynomial <M>p</M> with respect to a set of polynomials <M>Q</M>.
Here is the <E >Commutative Autoreduction Algorithm</E>:
<Listing><![CDATA[
Input: a set of polynomials P = {p_1,p_2,...,p_n} and an involutive division I 
  while there exists p_i in P such that rem_I(p_i, P\{p_i}) <> p_i do
    q := Rem_I(p_i, P\{p_i});
    P := P\{p_i};
    if (q<>0) then
      P := P union {q};
    fi;
  od;
  return P;
]]></Listing>
<P/>

It can be shown that if <M>P</M> is a set of polynomials 
over a polynomial ring <M>\mathcal{R} = \mathbb{F}[a_1,\ldots,a_n]</M>,
such that <M>P</M> is autoreduced with respect to an 
involutive division <M>I</M>,
and if <M>p,q</M> are two polynomials in <M>\mathcal{R}</M>, then
<M>rem_I(p,P) + rem_I(q,P) = rem_I(p+q,P)</M>.
<P/>
Given an involutive division <M>I</M> 
and an admissible monomial ordering <M>O</M>, 
an autoreduced set of polynomials <M>P</M> 
is a <E>locally involutive basis</E> with respect to <M>I</M> and <M>O</M>
if any prolongation of any <M>p_i \in P</M>
involutively reduces to zero using <M>P</M>.
Further, <M>P</M> is an <E>involutive basis</E>
with respect to <M>I</M> and <M>O</M> if any multiple <M>p_it</M>
of any <M>p_i \in P</M> by any term <M>t</M>
involutively reduces to zero using <M>P</M>.
<P/>

The <E>Commutative Involutive Basis Algorithm</E>:
<Listing><![CDATA[
Input: a basis F = {f_1,f_2,...,f_m} for an ideal J 
       over a commutative polynomial ring R[a_1,...,a_n];
       an admissible monomial ordering O; 
       a continuous and constructive involutive division I 
Output: an involutive basis G = {g_1,g_2,...,g_k} for J (if it terminates)
  G := { };
  F := autoreduction of F with respect to O and I;
  while G = { } do
    P := set of all prolongations f_i*a_j, 1<=i<=m, 1<=j<=n;
    q := 0;
    while (P <> { }) and (q=0) do
      p := a polynomial in P with minimal lead monomial w.r.t. O;
      P := P \ {p};
      q := rem_I(p,F);
    od;
    if (q <> 0) then  ## new basis element found
      F := autoreduction of (F union {q})
    else  ## all the prolongations have reduced to zero
      G := F;
    fi;
  od;
  return G;
]]></Listing>
<P/>
</Subsection>

<ManSection>
   <Func Name="InvolutiveBasis"
         Arg="alg polys order" />
   <Oper Name="InvolutiveBasisCP"
         Arg="alg polys order" />
<Description>
The global function <C>InvolutiveBasis</C> calls one of the operations
<C>InvolutiveBasisCP</C> and <C>InvolutiveBasisNP</C>
depending on whether the algebra is commutative or not.
This function finds an involutive basis for the ideal generated
by a set of polynomials, using a chosen ordering,
and returns a division record.
<P/>
Any involutive basis returned by this algorithm is a &Grob; basis, 
and remainders are involutively unique with respect to this basis.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ibasP := InvolutiveBasis( R, L2, ord );
rec( div := "Pommaret", mvars := [ [ 1, 2 ], [ 1 ], [ 1 ], [ 1 ] ], 
  polys := [ b^3-3*a, a^3-3*b, a^3*b-3*b^2, a^3*b^2-9*a ] )
gap> r := IPolyReduce( R, p, ibasP, ord );
9*a^2+9*a*b+6*b^2
]]>
</Example>

Here we have returned to the example in section <Ref Sect="DivisionRecord"/>.
Starting with <M>F=\{u,v\}</M>, there is only one prolongation, 
<M>P=\{w=vb\}</M>, and <M>F</M> becomes <M>\{u,v,w\}</M>. 
At the second iteration, <M>P=\{vb,wb\}</M>; <M>vb</M> reduces to zero;
<M>wb</M> reduces to <M>x=a^3b^2-9a</M>; 
and <M>F</M> becomes <M>\{u,v,w,x\}</M>.
At the third iteration <M>P=\{vb,wb,xb\}</M> and all three of these 
reduce to zero, so <M>G = F</M> is returned.
<P/>
It is then shown that the multiplicative variables for <M>\{u,v,w,x\}</M>
are <M>\{\{a,b\},\{a\},\{a\},\{a\}\}</M>.
<P/>
Finally, the full reduction <M>r</M> of <M>p</M> is computed.
<P/>
If, instead of the Pommaret division, we use Janet or Thomas we obtain:
<P/>
<Example>
<![CDATA[
gap> CommutativeDivision := "Janet";;
gap> ibasJ := InvolutiveBasis( R, L2, ord );;
gap> ( ibasJ.mvars = ibasP.mvars ) and ( ibasJ.polys = ibasP.polys );
true
gap> CommutativeDivision := "Thomas";;
gap> ibasT := InvolutiveBasis( R, L2, ord );
rec( div := "Thomas", 
  mvars := [ [ 2 ], [ 1 ], [ 2 ], [ 1 ], [ 2 ], [ 1 ], [ 1, 2 ] ], 
  polys := [ b^3-3*a, a^3-3*b, a*b^3-3*a^2, a^3*b-3*b^2, a^2*b^3-9*b, 
      a^3*b^2-9*a, a^3*b^3-9*a*b ] )
]]>
</Example>
The Janet division gives the same involutive basis as Pommaret,
but the Thomas Division produces <M>7</M>, rather than <M>4</M> polynomials:
<Display>
[u,v,y,w,z,x,t] ~=~
[~ b^3-3a,\ a^3-3b,\ ab^3-3a^2,\ a^3b-3b^2,\ 
   a^2b^3-9b,\ a^3b^2-9a,\  a^3b^3-9ab ~].
</Display>
<P/>
The multiplicative variables for these polynomials are
<M>[ \{b\}, \{a\}, \{b\}, \{a\}, \{b\}, \{a\}, \{a,b\} ]</M>,
so the reduction diagram for the Thomas basis is:
<Display>
<![CDATA[
\vcenter{\xymatrix@=1em{
 b & & & & & & & & \\
 : \ar[u] & \cdot & \cdot & \cdot \ar@{-}[ur]
              & \cdot & \cdot & \cdot & & \\
 5 \ar@{-}[u] & \cdot & \cdot & \cdot \ar@{-}[uurr]
              & \cdot & \cdot & \cdot & & \\
 4 \ar@{-}[u] & \cdot & \cdot 
              & \cdot \ar@{-}[uuurrr] & \cdot & \cdot & \cdot & & \\
 u \ar@{-}[u] & y \ar@{-}[uuuu] & z \ar@{-}[uuuu] 
              & t \ar@{-}[uuuurrrr] \ar@{-}[uuuu] \ar@{-}[rrrr]
              & \cdot \ar@{-}[uuurrr]
              & \cdot \ar@{-}[uurr] & \cdot \ar@{-}[ur] & & \\
 2 \ar@{-}[u] & \cdot & \cdot & x \ar@{-}[rrrr] 
                & \cdot & \cdot & \cdot & & \\
 1 \ar@{-}[u] & \cdot & \cdot & w \ar@{-}[rrrr]
                & \cdot & \cdot & \cdot & & \\
 0 \ar@{-}[r]\ar@{-}[u] & 1 \ar@{-}[r] & 2 \ar@{-}[r] 
    & v \ar@{-}[r] 
    & 4 \ar@{-}[r] & 5 \ar@{-}[r] & \cdots \ar[r] & a &
}}
]]></Display>

The reduction of <M>p</M> with this basis is:
<Display>
p = a^3b^3 + 2a^3b + 3ab^3
  \stackrel{t}{\longrightarrow} 2a^3b + 3ab^3 + 9ab 
  \stackrel{w}{\longrightarrow} 3ab^3 + 9ab + 6b^2 
  \stackrel{y}{\longrightarrow} 9a^2 + 9ab + 6b^2.
</Display>

<Example>
<![CDATA[
gap> r := LoggedIPolyReduceCP( R, p, ibasT, ord );
rec( logs := [ 0, 0, 3, 2, 0, 0, 1 ], 
  polys := [ b^3-3*a, a^3-3*b, a*b^3-3*a^2, a^3*b-3*b^2, a^2*b^3-9*b, 
      a^3*b^2-9*a, a^3*b^3-9*a*b ], result := 9*a^2+9*a*b+6*b^2 )
]]>
</Example>

<Subsection Label="subs-ex452"> 
<Heading>A more detailed example</Heading>

Here we consider Example 4.5.2 in the thesis <Cite Key='gareth-thesis'/>.
On setting <C>InfoLevel(InfoIBNP)</C> to <C>1</C> some of the intermediate calculations are displayed. 
The setting of the problem is a rational polynomial ring in three variables
with the lex ordering <M>[x,y,z]</M>, using the Janet involutive division.
<List>
<Item>
the initial basis contains two polynomials <M>\{a=x^2+y^3,~b=x+z^3\}</M>
</Item>
<Item>
the reduced &Grob; basis is <M>\{c=y^3+z^6,~b=x+z^3\}</M>, and the 
irreducible monomials are <M>\{z^k,~yz^k,~y^2z^k~|~ k \geqslant 0\}</M>
</Item>
<Item>
when starting to calculate an involutive basis, the autoreduction does nothing
because <M>x</M> is not multiplicative for <M>b</M>
</Item>
<Item>
the only prolongation is <M>bx = x^2+xz^3</M> which reduces, on subtracting
<M>a+bz^3</M> and changing the sign, to <M>c=y^3+z^6</M>
</Item>
<Item>
on restarting with basis <M>[c,b,a]</M>, autoreduction replaces <M>a</M>
with <M>a-c = d = x^2-z^6</M>
</Item>
<Item>
there are then <M>3</M> prolongations <M>[by,bx,dy]</M> and <M>bx</M>
now reduces to zero 
</Item>
<Item>
<M>by = e = xy+yz^3</M> is then added to the basis: <M>[c,b,e,d]</M>
</Item>
<Item>
<M>dy = x^2y-yz^6</M> reduces to zero on adding <M>e(-x+z^3)</M>
</Item>
<Item>
on restarting with basis <M>[c,b,e,d]</M> there are <M>4</M> 
prolongations <M>[by,ey,bx,dy]</M> and of these
only <M>f = ey = xy^2+y^2z^3</M> does not reduce to zero
</Item>
<Item>
restarting with basis <M>[c,b,e,f,d]</M>, the <M>5</M> prolongations
<M>[by,ey,fy,bx,dy]</M> all reduce to zero.
</Item>
<Item>
now see what happens when reducing <M>p = x^7+y^7+z^7</M> using the basis
<M>[c,b,e,f,d]</M>
</Item>
<Item>
<M>x^7-dx^5 = x^5z^6</M> and <M>x^5z^6 - dx^3z^6 = x^3z^{12}</M> 
and <M>x^3z^{12}-dxz^{12} = xz^{18}</M> and <M>xz^{18}-bz^{18}=-z^{21}</M>
</Item>
<Item>
<M>y^7 - cy^4 = -y^4z^6</M> and <M>-y^4z^6 + cyz^6 = yz^{12}</M>,
so <M>p</M> reduces to <M>-z^{21} + yz^{12} + z^7</M>.
</Item>
</List>

<Example>
<![CDATA[
gap> SetInfoLevel( InfoIBNP, 1 );; 
gap> CommutativeDivision := "Janet";;
gap> R3 := PolynomialRing( Rationals, [ "x", "y", "z" ] );;
gap> x := R3.1;; y := R3.2;; z := R3.3;; 
gap> ord3 := MonomialLexOrdering( [x,y,z] );;
gap> F := [ y^3 + x^2, z^3 + x ];;
gap> gbas := GrobnerBasis( F, ord3 );
[ y^3+x^2, z^3+x, -z^6-y^3 ]
gap> rgbas := ReducedGrobnerBasis( F, ord3 );
[ z^6+y^3, z^3+x ]
gap> ibasF := InvolutiveBasisCP( R3, F, ord3 );
#I  restarting with basis:
[ z^3+x, y^3+x^2 ]
#I  division record for basis: rec(
div := "Janet",
mvars := [ [ 2, 3 ], [ 1, 2, 3 ] ],
polys := [ z^3+x, y^3+x^2 ] )
#I  prolongations = [ x*z^3+x^2 ]
#I  restarting with basis:
[ z^6+y^3, z^3+x, y^3+x^2 ]
#I  after autoreduction basis = 
[ z^6+y^3, z^3+x, -z^6+x^2 ]
#I  division record for basis: rec(
div := "Janet",
mvars := [ [ 1, 2, 3 ], [ 3 ], [ 1, 3 ] ],
polys := [ z^6+y^3, z^3+x, -z^6+x^2 ] )
#I  prolongations = [ y*z^3+x*y, x*z^3+x^2, -y*z^6+x^2*y ]
#I  restarting with basis:
[ z^6+y^3, z^3+x, y*z^3+x*y, -z^6+x^2 ]
#I  division record for basis: rec(
div := "Janet",
mvars := [ [ 1, 2, 3 ], [ 3 ], [ 1, 3 ], [ 1, 3 ] ],
polys := [ z^6+y^3, z^3+x, y*z^3+x*y, -z^6+x^2 ] )
#I  prolongations = [ y*z^3+x*y, y^2*z^3+x*y^2, x*z^3+x^2, -y*z^6+x^2*y ]
#I  restarting with basis:
[ z^6+y^3, z^3+x, y*z^3+x*y, y^2*z^3+x*y^2, -z^6+x^2 ]
#I  division record for basis: rec(
div := "Janet",
mvars := [ [ 1, 2, 3 ], [ 3 ], [ 1, 3 ], [ 1, 3 ], [ 1, 3 ] ],
polys := [ z^6+y^3, z^3+x, y*z^3+x*y, y^2*z^3+x*y^2, -z^6+x^2 ] )
#I  prolongations = [ y*z^3+x*y, y^2*z^3+x*y^2, y^3*z^3+x*y^3, x*z^3+x^2, -y*z\
^6+x^2*y ]
rec( div := "Janet", 
  mvars := [ [ 1, 2, 3 ], [ 3 ], [ 1, 3 ], [ 1, 3 ], [ 1, 3 ] ], 
  polys := [ z^6+y^3, z^3+x, y*z^3+x*y, y^2*z^3+x*y^2, -z^6+x^2 ] )
gap> ## now for a reduction - reset the info level:
gap> SetInfoLevel( InfoIBNP, 2 );; 
gap> p := x^7 + y^7 + z^7;;
gap> IPolyReduce( R3, p, ibasF, ord3 );
#I  reduced to: x^5*z^6+y^7+z^7
#I  reduced to: x^3*z^12+y^7+z^7
#I  reduced to: x*z^18+y^7+z^7
#I  reduced to: -z^21+y^7+z^7
#I  reduced to: -z^21-y^4*z^6+z^7
#I  reduced to: -z^21+y*z^12+z^7
-z^21+y*z^12+z^7
]]>
</Example>

</Subsection>

<Subsection Label="subs-hompolys"> 
<Heading>Using homogeneous polynomials</Heading>

If the polynomials in an initial basis are not homogeneous
<Index>homogeneous polynomials</Index>
then they may be made homogeneous by adding an additional variable.
The resulting involutive basis will contain only homogeneous polynomials.
However, if these are de-homogenised by setting the additional variable
equal to <M>1</M>, the resulting basis may not be involutive.
<P/>
Applying this to the previous example, the resulting basis contains
<M>10</M> polynomials which include homogenised versions of <M>[c,b,e,f]</M>,
but not <M>d</M>.

<Example>
<![CDATA[
gap> SetInfoLevel( InfoIBNP, 0 );
gap> R4 := PolynomialRing( Rationals, [ "x", "y", "z", "t" ] );;
gap> x := R4.1;; y := R4.2;; z := R4.3;; t := R4.4;;
gap> ord4 := MonomialLexOrdering( [x,y,z,t] );;
gap> ibasH := InvolutiveBasisCP( R4, H, ord4 );
rec( div := "Janet",
  mvars := [ [ 1, 2, 3, 4 ], [ 1, 2, 3 ], [ 1, 3, 4 ], [ 1, 2, 3 ], 
      [ 1, 2, 3 ], [ 1, 3, 4 ], [ 1, 3, 4 ], [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ],
  polys := [ y^3*t^3+z^6, x*t^2+z^3, x*t^3+z^3*t, x*z^3-y^3*t, 
      x*z^3*t-y^3*t^2, x*y*t^3+y*z^3*t, x*y^2*t^3+y^2*z^3*t, x^2*t+y^3, 
      x^2*z*t+y^3*z, x^2*z^2*t+y^3*z^2 ] )
]]>
</Example>

</Subsection>



</Section>

</Chapter>
